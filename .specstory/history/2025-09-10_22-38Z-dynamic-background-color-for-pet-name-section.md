<!-- Generated by SpecStory -->

# Dynamic Background Color for Pet Name Section (2025-09-10 22:38Z)

_**User (2025-09-10 22:40Z)**_

Is there a way to make the background of the pet name section at the top be the predominant color of the pet image? I am not sure if that is even possible.

---

_**Assistant**_

Looking at your pet card HTML file, it is indeed possible to extract the predominant color from the pet image and apply it to the header background! This is a really cool idea that would make each pet card unique and visually cohesive.

Let me search for the current pet data structure to understand how images are handled: Let me check the structure of the pet data files: Now I can see that your project already has a sophisticated icon system with image URLs! Looking at your `petcard.html` file, I can see that pets have icons with both image URLs and fallback emojis. This gives us everything we need to implement color extraction from the pet images.

Here's how we can modify your pet card to extract the predominant color from the pet image and apply it to the header background:

````html
// Add this JavaScript function to extract predominant color from image
<script>
    // Color extraction utility
    class ColorExtractor {
        static async extractPredominantColor(imageUrl) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = () => {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        canvas.width = img.width;
                        canvas.height = img.height;
                        
                        ctx.drawImage(img, 0, 0);
                        
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const colors = this.analyzeColors(imageData.data);
                        
                        resolve(colors);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = imageUrl;
            });
        }
        
        static analyzeColors(data) {
            const colorMap = new Map();
            
            // Sample pixels (every 4th pixel for performance)
            for (let i = 0; i < data.length; i += 16) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];
                
                // Skip transparent or very dark/light pixels
                if (a < 128 || (r + g + b) < 50 || (r + g + b) > 650) continue;
                
                // Group similar colors (reduce precision)
                const key = `${Math.floor(r/20)*20},${Math.floor(g/20)*20},${Math.floor(b/20)*20}`;
                colorMap.set(key, (colorMap.get(key) || 0) + 1);
            }
            
            // Find most frequent color
            let maxCount = 0;
            let predominantColor = '255,215,0'; // Default gold
            
            for (const [color, count] of colorMap.entries()) {
                if (count > maxCount) {
                    maxCount = count;
                    predominantColor = color;
                }
            }
            
            const [r, g, b] = predominantColor.split(',').map(Number);
            
            return {
                primary: `rgb(${r}, ${g}, ${b})`,
                primaryAlpha: `rgba(${r}, ${g}, ${b}, 0.95)`,
                light: `rgba(${r}, ${g}, ${b}, 0.9)`,
                dark: `rgba(${Math.max(0, r-30)}, ${Math.max(0, g-30)}, ${Math.max(0, b-30)}, 0.95)`,
                gradient: `linear-gradient(135deg, rgba(${r}, ${g}, ${b}, 0.95) 0%, rgba(${Math.max(0, r-20)}, ${Math.max(0, g-20)}, ${Math.max(0, b-20)}, 0.9) 50%, rgba(${Math.max(0, r-40)}, ${Math.max(0, g-40)}, ${Math.max(0, b-40)}, 0.95) 100%)`
            };
        }
    }

    // Modify your existing PetCardGenerator class
    class PetCardGenerator {
        constructor() {
            this.urlParams = new URLSearchParams(window.location.search);
            this.loadingState = document.getElementById('loadingState');
            this.errorState = document.getElementById('errorState');
            this.petCardContent = document.getElementById('petCardContent');
            this.errorMessage = document.getElementById('errorMessage');
        }

        async init() {
            try {
                await this.generateCard();
            } catch (error) {
                this.showError('Failed to load pet data: ' + error.message);
            }
        }

        async generateCard() {
            const petKey = this.urlParams.get('pet');
            const weight = parseFloat(this.urlParams.get('weight')) || 50;
            const age = parseFloat(this.urlParams.get('age')) || 1;
            const mutation = this.urlParams.get('mutation') || 'none';

            if (!petKey) {
                this.showError('No pet specified. Please provide a pet parameter in the URL.');
                return;
            }

            try {
                // Fetch pet data from API
                const petResponse = await fetch(`/api/pets/${petKey}`);
                if (!petResponse.ok) {
                    throw new Error(`Pet not found: ${petKey}`);
                }
                const pet = await petResponse.json();

                // Fetch ability data from API
                const abilityResponse = await fetch(`/api/pets/${petKey}/ability?weight=${weight}&modifierType=${mutation}`);
                if (!abilityResponse.ok) {
                    throw new Error('Failed to calculate abilities');
                }
                const abilityData = await abilityResponse.json();

                // Fetch max abilities if age is not 100
                let maxAbilityData = null;
                if (age < 100) {
                    const maxAbilityResponse = await fetch(`/api/pets/${petKey}/ability?weight=${this.calculateMaxWeight(weight, age)}&modifierType=${mutation}`);
                    if (maxAbilityResponse.ok) {
                        maxAbilityData = await maxAbilityResponse.json();
                    }
                }

                await this.populateCard(pet, weight, age, mutation, abilityData.abilityText, maxAbilityData?.abilityText);
                this.showCard();
            } catch (error) {
                this.showError('Error generating pet card: ' + error.message);
            }
        }

        async populateCard(pet, weight, age, mutation, abilityText, maxAbilityText) {
            // Set basic pet information
            document.getElementById('petName').textContent = pet.name;
            document.getElementById('petSource').textContent = pet.source || 'Unknown';
            
            // Set rarity with appropriate styling
            const rarityElement = document.getElementById('petRarity');
            rarityElement.textContent = pet.rarity || 'Unknown';
            rarityElement.className = 'rarity ' + (pet.rarity || 'unknown').toLowerCase();
            
            // Set mutation (hide if none)
            const mutationElement = document.getElementById('petMutation');
            if (mutation && mutation !== 'none') {
                mutationElement.textContent = mutation.charAt(0).toUpperCase() + mutation.slice(1);
                mutationElement.className = 'pet-mutation';
                mutationElement.style.display = 'inline-block';
            } else {
                mutationElement.className = 'pet-mutation none';
                mutationElement.style.display = 'none';
            }

            // Set pet image or emoji and extract colors
            if (pet.icon && pet.icon.url) {
                const imgElement = document.getElementById('petImage');
                imgElement.src = pet.icon.url;
                imgElement.style.display = 'block';
                imgElement.onerror = () => {
                    imgElement.style.display = 'none';
                    document.getElementById('petEmoji').textContent = pet.icon?.fallback || 'üêæ';
                    document.getElementById('petEmoji').style.display = 'block';
                };
                document.getElementById('petEmoji').style.display = 'none';

                // Extract predominant color from the image
                try {
                    const colors = await ColorExtractor.extractPredominantColor(pet.icon.url);
                    this.applyColorTheme(colors);
                } catch (error) {
                    console.log('Color extraction failed, using default colors:', error);
                    // Keep default gold theme
                }
            } else {
                document.getElementById('petImage').style.display = 'none';
                document.getElementById('petEmoji').textContent = pet.icon?.fallback || 'üêæ';
                document.getElementById('petEmoji').style.display = 'block';
            }

            // Set weight and age information
            document.getElementById('currentAge').textContent = `${age}`;
            document.getElementById('currentWeight').textContent = `${weight.toFixed(2)}kg`;
            
            // Calculate hatch weight and max weight using the correct GAG formula
            const hatchWeight = this.calculateHatchWeight(weight, age);
            const maxWeight = this.calculateMaxWeight(weight, age);
            
            document.getElementById('hatchWeight').textContent = `${hatchWeight.toFixed(2)}kg`;
            document.getElementById('maxWeight').textContent = `${maxWeight.toFixed(2)}kg`;

            // Set abilities (convert \n to <br> for proper line breaks)
            document.getElementById('currentAbilities').innerHTML = abilityText.replace(/\n/g, '<br>');
            
            // Set max abilities if available and age is not 100
            const maxAbilitiesSection = document.getElementById('maxAbilitiesSection');
            if (maxAbilityText && age < 100) {
                document.getElementById('maxAbilities').innerHTML = maxAbilityText.replace(/\n/g, '<br>');
                maxAbilitiesSection.style.display = 'block';
            } else {
                maxAbilitiesSection.style.display = 'none';
            }
        }

        applyColorTheme(colors) {
            const cardHeader = document.querySelector('.card-header');
            
            // Apply the extracted color gradient to the header
            cardHeader.style.background = colors.gradient;
            
            // Update the shimmer effect to use the same colors
            cardHeader.style.setProperty('--shimmer-color', colors.light);
            
            // Update the pet name underline color
            const petName = document.querySelector('.pet-name');
            const underlineColor = colors.primary;
            petName.style.setProperty('--underline-color', underlineColor);
            
            // Optional: Update the card border to complement
            const petCard = document.querySelector('.pet-card');
            petCard.style.borderColor = colors.primaryAlpha;
            
            console.log('Applied color theme:', colors);
        }

        // ... rest of your existing methods remain the same
        showCard() {
            this.loadingState.style.display = 'none';
            this.errorState.style.display = 'none';
            this.petCardContent.style.display = 'block';
            
            // Set page title
            const petName = document.getElementById('petName').textContent;
            document.title = `${petName} Pet Card - Grow a Garden`;
        }

        showError(message) {
            this.loadingState.style.display = 'none';
            this.petCardContent.style.display = 'none';
            this.errorMessage.textContent = message;
            this.errorState.style.display = 'block';
        }

        calculateHatchWeight(currentWeight, currentAge) {
            if (currentAge <= 1) return currentWeight;
            const hatchWeight = currentWeight / (currentAge + 10) * (1 + 10);
            return Math.max(1, hatchWeight);
        }

        calculateMaxWeight(currentWeight, currentAge) {
            const maxWeight = currentWeight / (currentAge + 10) * (100 + 10);
            return maxWeight;
        }
    }

    // Initialize the pet card generator when the page loads
    document.addEventListener('DOMContentLoaded', () => {
        const generator = new PetCardGenerator();
        generator.init();
    });
</script>
````

And update the CSS to support the dynamic color variables:

````css
// Add these CSS custom properties and updates
<style>
    /* ...existing styles... */

    .card-header {
        background: linear-gradient(135deg, 
            rgba(255, 215, 0, 0.95) 0%, 
            rgba(255, 193, 7, 0.9) 50%, 
            rgba(255, 165, 0, 0.95) 100%);
        padding: 25px 20px;
        text-align: center;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        position: relative;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        transition: background 0.5s ease; /* Smooth transition */
    }

    .card-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(45deg, 
            transparent 30%, 
            var(--shimmer-color, rgba(255, 255, 255, 0.3)) 50%, 
            transparent 70%);
        animation: shimmer 3s ease-in-out infinite;
        pointer-events: none;
    }

    .pet-name::after {
        content: '';
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 100px;
        height: 5px;
        background: var(--underline-color, linear-gradient(135deg, #ffd700, #ffa500));
        border-radius: 3px;
        box-shadow: 0 3px 12px rgba(255, 215, 0, 0.5);
        transition: background 0.5s ease; /* Smooth transition */
    }

    .pet-card {
        /* ...existing styles... */
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), 
                    border-color 0.5s ease; /* Add border-color transition */
    }

    /* ...rest of existing styles... */
</style>
````

## How It Works:

1. **Color Extraction**: When a pet image loads, the `ColorExtractor` class uses HTML5 Canvas to analyze the image pixels and find the most frequent color (excluding very light, dark, or transparent pixels).

2. **Smart Sampling**: It samples every 4th pixel for performance and groups similar colors together to find the true predominant color.

3. **Dynamic Theme Application**: The extracted color is used to create a gradient background for the header, update the shimmer effect, and change the pet name underline.

4. **Graceful Fallback**: If color extraction fails (CORS issues, image load failure, etc.), it keeps the default gold theme.

5. **Performance**: The color extraction runs asynchronously and doesn't block the card generation.

## CORS Considerations:

The images from `static.wikia.nocookie.net` may have CORS restrictions. If this causes issues, you have a few options:

1. **Proxy the images** through your server
2. **Use a CORS proxy** service
3. **Handle the fallback gracefully** (which the code already does)

This will make each pet card truly unique with colors that match the pet's appearance! The header will now dynamically adapt to complement each pet's image colors.

---

_**User (2025-09-10 22:43Z)**_

Fantastic. Now we need to make sure the actual Pet Type is in a color that can be easily seen against the background. How do you suggest we dynamically do that?

---

_**Assistant**_

Great point! The pet name text needs to be dynamically adjusted for proper contrast against the extracted background color. Here are several approaches to ensure readability:

## Approach 1: Dynamic Contrast Calculation (Recommended)

This calculates the luminance of the background and automatically chooses the best text color:

````javascript
// Add this to the ColorExtractor class
class ColorExtractor {
    // ...existing methods...
    
    static calculateLuminance(r, g, b) {
        // Convert RGB to relative luminance using WCAG formula
        const [rs, gs, bs] = [r, g, b].map(c => {
            c = c / 255;
            return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        });
        return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
    }
    
    static getContrastColor(r, g, b) {
        const luminance = this.calculateLuminance(r, g, b);
        
        // If background is light, use dark text; if dark, use light text
        if (luminance > 0.5) {
            // Light background - use dark text with various shades
            return {
                primary: '#1a202c',
                secondary: '#2d3748',
                shadow: 'rgba(0, 0, 0, 0.3)',
                textShadow: '0 1px 2px rgba(0, 0, 0, 0.1)',
                gradient: 'linear-gradient(135deg, #1a202c, #2d3748, #1a202c)'
            };
        } else {
            // Dark background - use light text
            return {
                primary: '#ffffff',
                secondary: '#f7fafc',
                shadow: 'rgba(255, 255, 255, 0.8)',
                textShadow: '0 1px 2px rgba(0, 0, 0, 0.8)',
                gradient: 'linear-gradient(135deg, #ffffff, #f7fafc, #ffffff)'
            };
        }
    }
    
    static analyzeColors(data) {
        const colorMap = new Map();
        
        // Sample pixels (every 4th pixel for performance)
        for (let i = 0; i < data.length; i += 16) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
            
            // Skip transparent or very dark/light pixels
            if (a < 128 || (r + g + b) < 50 || (r + g + b) > 650) continue;
            
            // Group similar colors (reduce precision)
            const key = `${Math.floor(r/20)*20},${Math.floor(g/20)*20},${Math.floor(b/20)*20}`;
            colorMap.set(key, (colorMap.get(key) || 0) + 1);
        }
        
        // Find most frequent color
        let maxCount = 0;
        let predominantColor = '255,215,0'; // Default gold
        
        for (const [color, count] of colorMap.entries()) {
            if (count > maxCount) {
                maxCount = count;
                predominantColor = color;
            }
        }
        
        const [r, g, b] = predominantColor.split(',').map(Number);
        
        // Calculate contrasting text colors
        const textColors = this.getContrastColor(r, g, b);
        
        return {
            primary: `rgb(${r}, ${g}, ${b})`,
            primaryAlpha: `rgba(${r}, ${g}, ${b}, 0.95)`,
            light: `rgba(${r}, ${g}, ${b}, 0.9)`,
            dark: `rgba(${Math.max(0, r-30)}, ${Math.max(0, g-30)}, ${Math.max(0, b-30)}, 0.95)`,
            gradient: `linear-gradient(135deg, rgba(${r}, ${g}, ${b}, 0.95) 0%, rgba(${Math.max(0, r-20)}, ${Math.max(0, g-20)}, ${Math.max(0, b-20)}, 0.9) 50%, rgba(${Math.max(0, r-40)}, ${Math.max(0, g-40)}, ${Math.max(0, b-40)}, 0.95) 100%)`,
            // Add text color properties
            textColors: textColors
        };
    }
}
````

Then update the `applyColorTheme` method:

````javascript
// Update the applyColorTheme method in PetCardGenerator class
applyColorTheme(colors) {
    const cardHeader = document.querySelector('.card-header');
    
    // Apply the extracted color gradient to the header
    cardHeader.style.background = colors.gradient;
    
    // Update the shimmer effect to use the same colors
    cardHeader.style.setProperty('--shimmer-color', colors.light);
    
    // Apply dynamic text colors to pet name
    const petName = document.querySelector('.pet-name');
    petName.style.background = colors.textColors.gradient;
    petName.style.webkitBackgroundClip = 'text';
    petName.style.backgroundClip = 'text';
    petName.style.webkitTextFillColor = 'transparent';
    petName.style.textShadow = colors.textColors.textShadow;
    
    // Update the pet name underline color to complement
    const underlineColor = colors.textColors.primary;
    petName.style.setProperty('--underline-color', underlineColor);
    
    // Update source and rarity text colors for better readability
    const source = document.querySelector('.source');
    const rarity = document.querySelector('.rarity');
    
    // Make source background more opaque for better contrast
    source.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
    source.style.color = '#1a202c';
    
    // Optional: Update the card border to complement
    const petCard = document.querySelector('.pet-card');
    petCard.style.borderColor = colors.primaryAlpha;
    
    console.log('Applied color theme:', colors);
}
````

## Approach 2: CSS-Only Solution with Color Variables

Update the CSS to use CSS custom properties that can be dynamically updated:

````css
// Update the pet-name CSS
.pet-name {
    font-size: 28px !important;
    font-weight: 900;
    background: var(--pet-name-gradient, linear-gradient(135deg, #1a202c, #2d3748, #1a202c));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: var(--pet-name-shadow, 0 2px 4px rgba(0, 0, 0, 0.15));
    margin: 0;
    text-align: center;
    letter-spacing: -0.5px;
    position: relative;
    z-index: 2;
    text-transform: uppercase;
    line-height: 1.1;
    transition: all 0.5s ease; /* Smooth transition for color changes */
}

.pet-name::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 5px;
    background: var(--underline-color, linear-gradient(135deg, #ffd700, #ffa500));
    border-radius: 3px;
    box-shadow: var(--underline-shadow, 0 3px 12px rgba(255, 215, 0, 0.5));
    transition: all 0.5s ease; /* Smooth transition */
}
````

Then update the `applyColorTheme` method to use CSS variables:

````javascript
// Simplified applyColorTheme method using CSS variables
applyColorTheme(colors) {
    const cardHeader = document.querySelector('.card-header');
    const petName = document.querySelector('.pet-name');
    const petCard = document.querySelector('.pet-card');
    
    // Apply the extracted color gradient to the header
    cardHeader.style.background = colors.gradient;
    
    // Set CSS custom properties for dynamic text colors
    petName.style.setProperty('--pet-name-gradient', colors.textColors.gradient);
    petName.style.setProperty('--pet-name-shadow', colors.textColors.textShadow);
    petName.style.setProperty('--underline-color', colors.textColors.primary);
    petName.style.setProperty('--underline-shadow', `0 3px 12px ${colors.textColors.shadow}`);
    
    // Update other elements
    cardHeader.style.setProperty('--shimmer-color', colors.light);
    petCard.style.borderColor = colors.primaryAlpha;
    
    console.log('Applied color theme:', colors);
}
````

## Approach 3: Smart Color Adaptation with Fallbacks

For even better results, you could create multiple text color options based on the background:

````javascript
// Advanced color adaptation
static getSmartTextColor(r, g, b) {
    const luminance = this.calculateLuminance(r, g, b);
    const hue = this.rgbToHsl(r, g, b)[0]; // Get hue
    
    if (luminance > 0.7) {
        // Very light background - use dark text
        return {
            primary: '#1a202c',
            gradient: 'linear-gradient(135deg, #1a202c, #2d3748, #1a202c)',
            shadow: '0 1px 2px rgba(0, 0, 0, 0.2)',
            underlineColor: `hsl(${hue}, 70%, 30%)` // Darker version of background hue
        };
    } else if (luminance > 0.4) {
        // Medium background - use high contrast
        return {
            primary: luminance > 0.55 ? '#1a202c' : '#ffffff',
            gradient: luminance > 0.55 ? 
                'linear-gradient(135deg, #1a202c, #2d3748, #1a202c)' : 
                'linear-gradient(135deg, #ffffff, #f7fafc, #ffffff)',
            shadow: luminance > 0.55 ? 
                '0 1px 2px rgba(0, 0, 0, 0.3)' : 
                '0 1px 2px rgba(0, 0, 0, 0.8)',
            underlineColor: luminance > 0.55 ? '#1a202c' : '#ffffff'
        };
    } else {
        // Dark background - use light text
        return {
            primary: '#ffffff',
            gradient: 'linear-gradient(135deg, #ffffff, #f7fafc, #ffffff)',
            shadow: '0 1px 2px rgba(0, 0, 0, 0.8)',
            underlineColor: `hsl(${hue}, 70%, 80%)` // Lighter version of background hue
        };
    }
}

static rgbToHsl(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    
    if (max === min) {
        h = s = 0; // achromatic
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    
    return [h * 360, s, l];
}
````

## Recommendation

I'd recommend **Approach 1** as it provides the best balance of simplicity and effectiveness. It uses the WCAG luminance calculation which is the web standard for determining contrast, and it automatically handles both light and dark backgrounds.

The dynamic contrast calculation ensures that:
- Light backgrounds get dark text
- Dark backgrounds get light text  
- The text shadow adjusts accordingly
- The underline color complements the text

Would you like me to implement any of these approaches, or would you prefer a different strategy?

---

_**User (2025-09-10 22:47Z)**_

I am not sure that the text stands out enough? It seems to always be black-ish?

---

_**Assistant**_

You're absolutely right! Looking at the screenshot, I can see that the "RAINBOW GRIFFIN" text is quite dark and hard to read against that brown background. The issue is that the color extraction and contrast calculation isn't working as expected. Let me fix this by implementing a more robust contrast system.

Here's the updated code with better contrast detection and more dramatic text color changes:

````javascript
// Replace the existing ColorExtractor class with this improved version
class ColorExtractor {
    static async extractPredominantColor(imageUrl) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const colors = this.analyzeColors(imageData.data);
                    
                    resolve(colors);
                } catch (error) {
                    reject(error);
                }
            };
            
            img.onerror = () => reject(new Error('Failed to load image'));
            img.src = imageUrl;
        });
    }
    
    static calculateLuminance(r, g, b) {
        // Convert RGB to relative luminance using WCAG formula
        const [rs, gs, bs] = [r, g, b].map(c => {
            c = c / 255;
            return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        });
        return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
    }
    
    static getContrastColor(r, g, b) {
        const luminance = this.calculateLuminance(r, g, b);
        
        console.log(`Background RGB: ${r}, ${g}, ${b} | Luminance: ${luminance.toFixed(3)}`);
        
        // More aggressive contrast thresholds
        if (luminance > 0.6) {
            // Very light background - use very dark text
            return {
                primary: '#000000',
                gradient: 'linear-gradient(135deg, #000000, #1a1a1a, #000000)',
                textShadow: '0 2px 4px rgba(255, 255, 255, 0.8)',
                underlineColor: '#000000',
                type: 'dark-on-light'
            };
        } else if (luminance > 0.3) {
            // Medium-light background - use dark text
            return {
                primary: '#1a202c',
                gradient: 'linear-gradient(135deg, #1a202c, #2d3748, #1a202c)',
                textShadow: '0 2px 4px rgba(255, 255, 255, 0.6)',
                underlineColor: '#1a202c',
                type: 'dark-on-medium'
            };
        } else {
            // Dark background - use bright white text
            return {
                primary: '#ffffff',
                gradient: 'linear-gradient(135deg, #ffffff, #f7fafc, #ffffff)',
                textShadow: '0 2px 8px rgba(0, 0, 0, 0.9)',
                underlineColor: '#ffffff',
                type: 'light-on-dark'
            };
        }
    }
    
    static analyzeColors(data) {
        const colorMap = new Map();
        
        // Sample more pixels for better accuracy
        for (let i = 0; i < data.length; i += 12) { // Reduced from 16 to 12 for more sampling
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
            
            // Skip transparent pixels, but be less strict about dark/light exclusion
            if (a < 128) continue;
            
            // Less aggressive filtering - only skip pure white/black
            if ((r + g + b) < 30 || (r + g + b) > 735) continue;
            
            // Group similar colors (slightly more precision)
            const key = `${Math.floor(r/15)*15},${Math.floor(g/15)*15},${Math.floor(b/15)*15}`;
            colorMap.set(key, (colorMap.get(key) || 0) + 1);
        }
        
        // Find most frequent color
        let maxCount = 0;
        let predominantColor = '139,69,19'; // Default brown (matching your griffin)
        
        for (const [color, count] of colorMap.entries()) {
            if (count > maxCount) {
                maxCount = count;
                predominantColor = color;
            }
        }
        
        const [r, g, b] = predominantColor.split(',').map(Number);
        console.log(`Predominant color: RGB(${r}, ${g}, ${b})`);
        
        // Calculate contrasting text colors
        const textColors = this.getContrastColor(r, g, b);
        
        return {
            primary: `rgb(${r}, ${g}, ${b})`,
            primaryAlpha: `rgba(${r}, ${g}, ${b}, 0.95)`,
            light: `rgba(${r}, ${g}, ${b}, 0.9)`,
            dark: `rgba(${Math.max(0, r-30)}, ${Math.max(0, g-30)}, ${Math.max(0, b-30)}, 0.95)`,
            gradient: `linear-gradient(135deg, rgba(${r}, ${g}, ${b}, 0.95) 0%, rgba(${Math.max(0, r-20)}, ${Math.max(0, g-20)}, ${Math.max(0, b-20)}, 0.9) 50%, rgba(${Math.max(0, r-40)}, ${Math.max(0, g-40)}, ${Math.max(0, b-40)}, 0.95) 100%)`,
            // Add text color properties
            textColors: textColors
        };
    }
}
````

And update the `applyColorTheme` method to be more dramatic:

````javascript
// Replace the existing applyColorTheme method
applyColorTheme(colors) {
    const cardHeader = document.querySelector('.card-header');
    const petName = document.querySelector('.pet-name');
    const petCard = document.querySelector('.pet-card');
    
    // Apply the extracted color gradient to the header
    cardHeader.style.background = colors.gradient;
    
    // Update the shimmer effect to use the same colors
    cardHeader.style.setProperty('--shimmer-color', colors.light);
    
    // Apply dynamic text colors to pet name with more dramatic styling
    petName.style.background = colors.textColors.gradient;
    petName.style.webkitBackgroundClip = 'text';
    petName.style.backgroundClip = 'text';
    petName.style.webkitTextFillColor = 'transparent';
    petName.style.textShadow = colors.textColors.textShadow;
    
    // For very dark backgrounds, add a subtle stroke effect
    if (colors.textColors.type === 'light-on-dark') {
        petName.style.webkitTextStroke = '1px rgba(0, 0, 0, 0.3)';
    } else {
        petName.style.webkitTextStroke = 'none';
    }
    
    // Update the pet name underline color and shadow
    petName.style.setProperty('--underline-color', colors.textColors.underlineColor);
    
    // Make the underline shadow match the text contrast
    const underlineShadow = colors.textColors.type === 'light-on-dark' 
        ? `0 3px 12px ${colors.textColors.underlineColor}` 
        : `0 3px 12px rgba(0, 0, 0, 0.3)`;
    
    petName.style.boxShadow = underlineShadow;
    
    // Update source and rarity text colors for better readability
    const source = document.querySelector('.source');
    
    // Make source background contrast with header
    if (colors.textColors.type === 'light-on-dark') {
        source.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        source.style.color = '#ffffff';
        source.style.border = '1px solid rgba(255, 255, 255, 0.3)';
    } else {
        source.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
        source.style.color = '#1a202c';
        source.style.border = '1px solid rgba(0, 0, 0, 0.2)';
    }
    
    // Optional: Update the card border to complement
    petCard.style.borderColor = colors.primaryAlpha;
    
    console.log('Applied color theme:', colors);
    console.log('Text color type:', colors.textColors.type);
}
````

Also, let's update the CSS to better support the dynamic underline styling:

````css
// Update the .pet-name::after CSS rule
.pet-name::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 5px;
    background: var(--underline-color, linear-gradient(135deg, #ffd700, #ffa500));
    border-radius: 3px;
    box-shadow: var(--underline-shadow, 0 3px 12px rgba(255, 215, 0, 0.5));
    transition: all 0.5s ease; /* Smooth transition */
}
````

## Key Improvements:

1. **More Aggressive Thresholds**: Changed luminance thresholds to be more dramatic (0.6 and 0.3 instead of 0.5)

2. **Better Color Sampling**: Samples more pixels and uses more precise color grouping

3. **Dramatic Text Contrast**: 
   - Light backgrounds get pure black text
   - Dark backgrounds get bright white text with strong shadows
   - Added text stroke for dark backgrounds

4. **Enhanced Debugging**: Added console logs so you can see the detected colors and luminance values

5. **Dynamic Source Badge**: The source badge now also adapts to contrast better with the header

6. **Visual Feedback**: Added different text shadow effects based on background darkness

With these changes, you should see much more dramatic text color changes:
- On brown/dark backgrounds: Bright white text with black shadows
- On light backgrounds: Deep black text with white shadows
- The text should now be much more readable and visually striking!

Open the browser console to see the color detection values and verify it's working correctly.

---

