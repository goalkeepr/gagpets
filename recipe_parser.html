<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recipe Parser</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .input-section {
            margin-bottom: 20px;
        }
        
        textarea {
            width: 100%;
            height: 200px;
            font-family: monospace;
            font-size: 12px;
        }
        
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        .output-section {
            margin-top: 20px;
        }
        
        .stats {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            font-size: 12px;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 6px 8px;
            text-align: left;
        }
        
        th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
        }
        
        .verified-yes {
            background-color: #d4edda;
        }
        
        .verified-no {
            background-color: #f8d7da;
        }
        
        .table-container {
            max-height: 600px;
            overflow: auto;
            border: 1px solid #ddd;
        }
        
        .ingredient-count {
            font-weight: bold;
            color: #28a745;
        }
        
        .download-section {
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>Recipe Data Parser</h1>
    
    <div class="input-section">
        <h2>Input HTML Data</h2>
        <textarea id="htmlInput" placeholder="Paste your recipe HTML data here..."></textarea>
        <br>
        <button onclick="parseRecipes()">Parse Recipes</button>
        <button onclick="loadSampleData()">Load Sample Data</button>
    </div>
    
    <div class="output-section">
        <div id="stats" class="stats" style="display: none;">
            <h3>Parsing Results</h3>
            <p>Recipes found: <span id="recipeCount">0</span></p>
            <p>Unique ingredients: <span id="ingredientCount">0</span></p>
        </div>
        
        <div class="download-section" id="downloadSection" style="display: none;">
            <button onclick="downloadCSV()">Download CSV</button>
            <button onclick="downloadJSON()">Download JSON</button>
            <button onclick="copyCSV()">Copy CSV to Clipboard</button>
        </div>
        
        <div class="table-container" id="tableContainer" style="display: none;">
            <table id="recipeTable">
                <thead id="tableHead"></thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>
    </div>

    <script>
        // Include the recipe parser code directly
        class CookingEventRecipeParser {
            constructor() {
                this.recipes = [];
                this.allIngredients = new Set();
            }
            
            parseRecipeHTML(htmlContent) {
                this.recipes = [];
                this.allIngredients = new Set();
                
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                
                // Find the main tabber
                const mainTabber = doc.querySelector('.tabber.wds-tabber');
                if (!mainTabber) {
                    console.warn('Main tabber not found, trying alternative approach');
                    return this.parseAlternativeStructure(doc);
                }
                
                // Get all main tabs (food items)
                const mainTabs = mainTabber.querySelectorAll(':scope > .wds-tabs__wrapper > .wds-tabs > .wds-tabs__tab');
                const mainContents = mainTabber.querySelectorAll(':scope > .wds-tab__content');
                
                mainTabs.forEach((tab, index) => {
                    const itemName = tab.querySelector('a').textContent.trim();
                    const content = mainContents[index];
                    
                    if (content) {
                        this.parseItemTabContent(itemName, content);
                    }
                });
                
                return this.createRecipeTable();
            }
            
            parseAlternativeStructure(doc) {
                // Fallback parsing for different HTML structures
                const allTabs = doc.querySelectorAll('.wds-tabs__tab');
                const allContents = doc.querySelectorAll('.wds-tab__content');
                
                // Try to identify food items vs rarities
                const foodItems = ['Salad', 'Sandwich', 'Pie', 'Waffle', 'Hot Dog', 'Ice Cream', 'Donut', 'Pizza', 'Sushi', 'Cake', 'Burger'];
                
                allTabs.forEach((tab, index) => {
                    const tabName = tab.querySelector('a').textContent.trim();
                    if (foodItems.includes(tabName) && allContents[index]) {
                        this.parseItemTabContent(tabName, allContents[index]);
                    }
                });
                
                return this.createRecipeTable();
            }
            
            parseItemTabContent(itemName, content) {
                const nestedTabber = content.querySelector('.tabber.wds-tabber');
                
                if (nestedTabber) {
                    const rarityTabs = nestedTabber.querySelectorAll(':scope > .wds-tabs__wrapper > .wds-tabs > .wds-tabs__tab');
                    const rarityContents = nestedTabber.querySelectorAll(':scope > .wds-tab__content');
                    
                    rarityTabs.forEach((tab, index) => {
                        const rarity = tab.querySelector('a').textContent.trim();
                        const rarityContent = rarityContents[index];
                        
                        if (rarityContent) {
                            this.parseRarityContentAdvanced(itemName, rarity, rarityContent);
                        }
                    });
                } else {
                    this.parseRarityContentAdvanced(itemName, 'Normal', content);
                }
            }
            
            parseRarityContentAdvanced(itemName, rarity, content) {
                const textContent = content.textContent;
                
                // Look for option patterns
                const optionMatches = [];
                const optionRegex = /(\d+(?:st|nd|rd|th)\s+Option[^:]*):?\s*([✅❌🟡]*)/g;
                let match;
                
                while ((match = optionRegex.exec(textContent)) !== null) {
                    optionMatches.push({
                        index: match.index,
                        label: match[1].trim(),
                        verified: match[2].includes('✅'),
                        fullMatch: match[0]
                    });
                }
                
                const allLists = content.querySelectorAll('ul');
                
                if (optionMatches.length > 0) {
                    optionMatches.forEach((optionMatch, optionIndex) => {
                        const nextOptionIndex = optionIndex + 1 < optionMatches.length ? 
                            optionMatches[optionIndex + 1].index : textContent.length;
                        
                        const relevantLists = [];
                        allLists.forEach(list => {
                            const listText = list.textContent;
                            const listIndex = textContent.indexOf(listText);
                            
                            if (listIndex > optionMatch.index && listIndex < nextOptionIndex) {
                                relevantLists.push(list);
                            }
                        });
                        
                        if (relevantLists.length > 0) {
                            const ingredients = this.parseIngredientList(relevantLists[0]);
                            
                            if (ingredients.length > 0) {
                                ingredients.forEach(ing => this.allIngredients.add(ing.name));
                                
                                this.recipes.push({
                                    item: itemName,
                                    rarity: rarity,
                                    option: optionIndex + 1,
                                    verified: optionMatch.verified,
                                    ingredients: ingredients,
                                    note: this.extractNoteFromContext(textContent, optionMatch.index, nextOptionIndex)
                                });
                            }
                        }
                    });
                } else {
                    allLists.forEach((list, index) => {
                        const ingredients = this.parseIngredientList(list);
                        
                        if (ingredients.length > 0) {
                            ingredients.forEach(ing => this.allIngredients.add(ing.name));
                            
                            this.recipes.push({
                                item: itemName,
                                rarity: rarity,
                                option: index + 1,
                                verified: false,
                                ingredients: ingredients,
                                note: ''
                            });
                        }
                    });
                }
            }
            
            parseIngredientList(listElement) {
                const ingredients = [];
                const listItems = listElement.querySelectorAll('li');
                
                listItems.forEach(li => {
                    const text = li.textContent.trim();
                    const ingredient = this.parseIngredientText(text);
                    
                    if (ingredient) {
                        ingredients.push(ingredient);
                    }
                });
                
                return ingredients;
            }
            
            parseIngredientText(text) {
                let match = text.match(/^(\d+)x?\s+(.+?)(?:\s+\(|$)/);
                
                if (match) {
                    const [, quantity, nameWithExtras] = match;
                    let name = nameWithExtras;
                    
                    if (name.includes(' or ')) {
                        name = name.split(' or ')[0];
                    }
                    
                    name = name.replace(/\s*\([^)]+\).*$/, '').trim();
                    
                    return {
                        name: name,
                        quantity: parseInt(quantity)
                    };
                }
                
                return null;
            }
            
            extractNoteFromContext(textContent, startIndex, endIndex) {
                const contextText = textContent.substring(startIndex, endIndex);
                
                const notePatterns = [
                    /\(has to be \d+kg\+[^)]*\)/i,
                    /must be in order/i,
                    /everything should be in order/i,
                    /at least \d+ .+? type/i,
                    /sometimes gives .+?\]/i,
                    /this one can be in any order/i,
                    /rarer .+? have .+? chance/i
                ];
                
                for (const pattern of notePatterns) {
                    const match = contextText.match(pattern);
                    if (match) {
                        return match[0];
                    }
                }
                
                return '';
            }
            
            createRecipeTable() {
                const ingredientsList = Array.from(this.allIngredients).sort();
                const headers = ['Item', 'Rarity', 'Option', 'Verified', 'Note', ...ingredientsList];
                
                const rows = this.recipes.map(recipe => {
                    const row = {
                        Item: recipe.item,
                        Rarity: recipe.rarity,
                        Option: recipe.option,
                        Verified: recipe.verified ? 'Yes' : 'No',
                        Note: recipe.note
                    };
                    
                    ingredientsList.forEach(ingredient => {
                        row[ingredient] = 0;
                    });
                    
                    recipe.ingredients.forEach(ingredient => {
                        if (row.hasOwnProperty(ingredient.name)) {
                            row[ingredient.name] = ingredient.quantity;
                        }
                    });
                    
                    return row;
                });
                
                return {
                    headers: headers,
                    rows: rows,
                    ingredientCount: ingredientsList.length,
                    recipeCount: this.recipes.length
                };
            }
            
            exportToCSV(data) {
                const csvRows = [];
                csvRows.push(data.headers.join(','));
                
                data.rows.forEach(row => {
                    const csvRow = data.headers.map(header => {
                        const value = row[header] || 0;
                        if (typeof value === 'string' && value.includes(',')) {
                            return `"${value}"`;
                        }
                        return value;
                    });
                    csvRows.push(csvRow.join(','));
                });
                
                return csvRows.join('\n');
            }
            
            exportToJSON(data) {
                return JSON.stringify(data, null, 2);
            }
        }

        // Global variables
        let currentData = null;
        let parser = new CookingEventRecipeParser();

        function parseRecipes() {
            const htmlInput = document.getElementById('htmlInput').value;
            
            if (!htmlInput.trim()) {
                alert('Please paste HTML data first');
                return;
            }
            
            try {
                currentData = parser.parseRecipeHTML(htmlInput);
                displayResults(currentData);
            } catch (error) {
                alert('Error parsing HTML: ' + error.message);
                console.error(error);
            }
        }

        function displayResults(data) {
            // Update stats
            document.getElementById('recipeCount').textContent = data.recipeCount;
            document.getElementById('ingredientCount').textContent = data.ingredientCount;
            document.getElementById('stats').style.display = 'block';
            document.getElementById('downloadSection').style.display = 'block';
            
            // Create table
            const tableHead = document.getElementById('tableHead');
            const tableBody = document.getElementById('tableBody');
            
            // Clear existing content
            tableHead.innerHTML = '';
            tableBody.innerHTML = '';
            
            // Create header row
            const headerRow = document.createElement('tr');
            data.headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                if (header !== 'Item' && header !== 'Rarity' && header !== 'Option' && header !== 'Verified' && header !== 'Note') {
                    th.classList.add('ingredient-count');
                }
                headerRow.appendChild(th);
            });
            tableHead.appendChild(headerRow);
            
            // Create data rows
            data.rows.forEach(row => {
                const tr = document.createElement('tr');
                data.headers.forEach(header => {
                    const td = document.createElement('td');
                    const value = row[header] || 0;
                    td.textContent = value;
                    
                    if (header === 'Verified') {
                        td.classList.add(value === 'Yes' ? 'verified-yes' : 'verified-no');
                    }
                    
                    tr.appendChild(td);
                });
                tableBody.appendChild(tr);
            });
            
            document.getElementById('tableContainer').style.display = 'block';
        }

        function downloadCSV() {
            if (!currentData) return;
            
            const csv = parser.exportToCSV(currentData);
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'recipes.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function downloadJSON() {
            if (!currentData) return;
            
            const json = parser.exportToJSON(currentData);
            const blob = new Blob([json], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'recipes.json';
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function copyCSV() {
            if (!currentData) return;
            
            const csv = parser.exportToCSV(currentData);
            navigator.clipboard.writeText(csv).then(() => {
                alert('CSV data copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        function loadSampleData() {
            const sampleHTML = `<div class="tabber wds-tabber"><div class="wds-tabs__wrapper with-bottom-border"><ul class="wds-tabs"><li class="wds-tabs__tab wds-is-current" data-hash="Salad"><div class="wds-tabs__tab-label"><a href="#">Salad</a></div></li></ul></div><div class="wds-tab__content wds-is-current"><div class="tabber wds-tabber"><div class="wds-tabs__wrapper with-bottom-border"><ul class="wds-tabs"><li class="wds-tabs__tab wds-is-current" data-hash="Normal"><div class="wds-tabs__tab-label"><a href="#">Normal</a></div></li></ul></div><div class="wds-tab__content wds-is-current"><p>Normal</p><p><u>1st Option ✅</u>:</p><ul><li>2x Tomato</li></ul><p><u>2nd Option ✅️</u>:</p><ul><li>1x Strawberry</li><li>1x Bell Pepper</li></ul></div></div></div>`;
            
            document.getElementById('htmlInput').value = sampleHTML;
        }
    </script>
</body>
</html>
